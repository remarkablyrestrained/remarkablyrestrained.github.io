<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Remarkably Restrained</title>
    <description>the title is misleading</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 26 Jul 2019 22:49:21 +0200</pubDate>
    <lastBuildDate>Fri, 26 Jul 2019 22:49:21 +0200</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>Things I'll never do</title>
        <description>&lt;p&gt;One of the trueisms of life is that there are always more exiting possibilities and plans than there is available time.&lt;/p&gt;

&lt;p&gt;This means that there are certain exiting plans that will dangle at the bottom of a &lt;em&gt;TODO&lt;/em&gt; file &lt;em&gt;forever&lt;/em&gt;. There, it may cause regret (“I’ll probably never be able to do this”) or anxiety (“I wish I could do this if only I had some more time”).&lt;/p&gt;

&lt;p&gt;Here’s a neat trick: write briefly about the plan as if you’ve already done it. And then remove the plan from your &lt;em&gt;TODO&lt;/em&gt; file forever.&lt;/p&gt;

&lt;p&gt;Writing about the plan gives at least part of the satisfaction of actually executing it. (In fact, this is precisely one of the dangers of making grandiose public declarations of intent: doing so gives us part of the reward already, and as such might actually make us less likely to achieve our goals. By using the “things I’ll never do” strategy, we use this danger to our advantage.)&lt;/p&gt;

&lt;p&gt;Of course, writing about a plan can be done in much less time than actually doing it. In that sense it is a solution for the fact that there is never enough time.&lt;/p&gt;

&lt;p&gt;Finally, by writing about them, we might be able to let them go.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jun 2018 00:00:00 +0200</pubDate>
        <link>/things-ill-never-do/</link>
        <guid isPermaLink="true">/things-ill-never-do/</guid>
        
        
      </item>
    
      <item>
        <title>Software bloat makes me sad</title>
        <description>&lt;p&gt;Most software is bloated, meaning: it’s taking both a lot more space to store (both in memory and on disk) and more time to run than required. A few examples:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.ubuntu.com/community/Installation/SystemRequirements&quot;&gt;The system requirements of the popular Linux distrubtion Ubuntu&lt;/a&gt; state that: “we all know that it is recommended to have 2048 MiB RAM to properly run a day to day Ubuntu” and &lt;a href=&quot;http://ubuntuforums.org/showthread.php?t=2171565&quot;&gt;its “Live CD” has grown so big as to no longer actually fit on a CD&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The “text editor we’ve always wanted” that’s currently being built at GitHub (atom.io) &lt;a href=&quot;https://github.com/atom/atom/issues/307#event-325455529&quot;&gt;has no support for 20% of use-cases involving&lt;/a&gt; ‘large files’ (&lt;a href=&quot;https://github.com/atom/atom/issues/307#issuecomment-48525797&quot;&gt;defined as files larger than a whopping 2MB&lt;/a&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Running the “lightweight” editor Vim, in combination with a few small extensions &lt;a href=&quot;https://github.com/klen/python-mode/issues/378&quot;&gt;may lead to your machine locking up for a full minute&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The above examples are in no way meant to single out certain pieces of software; them making it to this list is related only to my own personal recent experiences with them. Given that, rather than looking at the above examples in particular, the general point is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The magnitudy of bloat is almost incomprehensible. Many programs have grown with more than a thousand-fold with respect to their equivalents 2 decades ago. The same CD that hasn’t been able to fit Ubuntu since 2011 still fits approximately 150,000 pages of unformatted English text without any compression.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The burden of selecting software that is not bloated is entirely on the user. The default is bloated, if you want the unbloated version, you’ll have to work (search) for it yourself. And in many cases (e.g. anything that needs a web browser) such a search may not even be fruitful.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There are very little tools available to to help the user select unbloated software. Very few packages make any claims about their storage and runtime charactaristics at all (in fact, when composing the above list an internet search was of very little help for exactly this reason), except those that are specifically created with the purpose of not being bloated.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Over time, the battle against bloat is always lost. Even Ubuntu, which has traditionally presented itself (besides other things) as a method to extract a few extra life-years out of old hardware, is mentioned in the list above. In other words: it’s only less bloated than the alternatives.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;philosophical-underpinnings&quot;&gt;Philosophical underpinnings&lt;/h2&gt;

&lt;p&gt;So why is software so bloated? I’m not quite sure, and this article is an attempt to get closer to the answer rather than to present the one and final truth about the matter. However, I do have at least &lt;em&gt;some&lt;/em&gt; idea.&lt;/p&gt;

&lt;p&gt;Firstly, software is bloated because software developers believe writing bloated software is actually the right thing to do. By this I mean that, generally, software developers believe some instance of the following basic argument:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Constructing software without care for its performance characteristics is easier than with the extra consideration of “not making things bloated”&lt;/li&gt;
  &lt;li&gt;Software developer time is expensive.&lt;/li&gt;
  &lt;li&gt;Hardware is cheap, and is becoming cheaper all the time.&lt;/li&gt;
  &lt;li&gt;Therefore, it is best to think about optimizing the performance of software only once it becomes a noticable problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In many cases, this is combined with the “Agile” belief that “requirements will surely change, therefore it’s more important than anything (including writing something non-bloated) to get something out the door”.&lt;/p&gt;

&lt;p&gt;Some real-life examples of this philosphy are &lt;a href=&quot;http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast&quot;&gt;Make it work, make it right, make it fast&lt;/a&gt; (though the last step is often forgotten), the often misunderstood &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;“Premature optimization is the root of all evil”&lt;/a&gt; and &lt;a href=&quot;http://www.joelonsoftware.com/articles/fog0000000020.html&quot;&gt;this article by Joel Spolsky&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In other words: software bloat is &lt;em&gt;not&lt;/em&gt; an accident, but rather logical outcome of the belief-set of the field of software development. It’s not that we’re trying to keep a check on bloat and failing; it’s that we’re not even trying at all.&lt;/p&gt;

&lt;h3 id=&quot;lack-of-tools&quot;&gt;Lack of tools&lt;/h3&gt;

&lt;p&gt;This fundamental lack of care for building unbloated software is directly reflected in the lack of readily available tools which have performance as a focus. &lt;sup id=&quot;fnref:knowledge-disclaimer&quot;&gt;&lt;a href=&quot;#fn:knowledge-disclaimer&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Of course, tools exist which have performance as their focus. The generally available ones, however, all focus on “testing” or “analyzing”. In other words, they are empirical in nature, as they focus on &lt;em&gt;measuring&lt;/em&gt; performance generally, or &lt;em&gt;measuring&lt;/em&gt; which particular parts of the software are bloated. This fits with the earlier observation that the reduction bloat of software only receives attention once it becomes a “noticable problem”. Surely there is a place for empirical tools and methods in general. However, if they form the prime method of understanding artifacts of our own creation, we must surely become suspicious.&lt;/p&gt;

&lt;p&gt;A particular area of interest are the tools we have for decomposition &amp;amp; composition: breaking complex systems into parts that can be understood, and building systems out of such parts. Many tools for decomposition exist, such as dividing a system into different processes, modules, libraries, classes, methods etc. However, performance considerations can generally not be specified at the interfaces across which we decompose. On the contrary, they are often explicitly considered to be an implementation detail that we must abstract away from.&lt;/p&gt;

&lt;p&gt;To wit: the fact that a Java List Interface may be implemented using either a LinkedList or an ArrayList, implementations which have vastly different performance charactaristics, is (rightly) claimed as a victory for abstraction. However, the obvious consequence of this is that users of such a general interface cannot know what the performance consequences of their actions will be. Which means that with regards to performance, they will have to study the actual implementation, defeating the purpose of formalizing the interface. Furthermore: because the system is decomposed, stuying the actual implementation may not be sufficient once the implementation changes. And because such formalisms are lacking at every single boundary, bad decisisions with regards to bloat can propagate through systems without being noticed and may be introduced at any point in time.&lt;/p&gt;

&lt;p&gt;In short, the lack of formalisms means that the only thing preventing a system from becoming more bloated is the care taken by all individual programmers to construct an unbloated system.
Given the lack of focus on containing bloat, and the many other pressures on programmers to deliver, this is not a hopeful position to be in.&lt;/p&gt;

&lt;h2 id=&quot;the-case-against-bloat&quot;&gt;The case against bloat&lt;/h2&gt;

&lt;p&gt;So why is bloat so problematic in the first place? Shouldn’t I stop “moaning” about this non-existant problem as mr. Spolsky suggests? A few points:&lt;/p&gt;

&lt;p&gt;Firstly, for any usage that actually matters, performance &lt;em&gt;will&lt;/em&gt; in fact, at some point, become a problem when this approach is taken. In other words: any succesful application will at some point run into performance problems. Given the assumption of useful software, this means that the performance problems need to be solved at that point in time.&lt;/p&gt;

&lt;p&gt;This raises the question “wouldn’t it have been easier not to create the problem in the first place?” It would seem obvious that the answer to this is indeed “yes”. In a scenario of “doing it right at the first try” none of the costs asociated with the repeated work of re-understanding the problem space (potentially even by different persons) will be incurred. So at least in scenarios where succes is expected, it’s clearly best to “optimize” from the start.&lt;/p&gt;

&lt;p&gt;The usual counter to this is that the actual (as opposed to imagined) bottlenecks will only become apparent after intense usage. I find this hard to believe. This would imply that either the constructed software or the usage scenarios are hardly understood (though a cynical observer would rule out neither option). In fact, in my experience the process of finding such bottlenecks on running systems is itself quite time-consuming - time which cannot be spent actually reducing bloat. Case in point: which part of Ubuntu must we shave off, now that we notice it doesn’t fit on a CD anymore? Apperantly this question is sufficiently hard to remain open for the past four years.&lt;/p&gt;

&lt;p&gt;Secondly, having bloat in itself creates all kinds of new complexity, such as managing more hardware (since bloated software won’t fit on a single machine), &lt;a href=&quot;http://martinfowler.com/bliki/TwoHardThings.html&quot;&gt;the introduction of caching layers&lt;/a&gt;, shifting parts of the program into background processes (hiding parts of the slowness from your user) or even &lt;a href=&quot;https://developer.atlassian.com/blog/2015/03/the-new-svg-hipchat-loading-screen-faster-without-react/&quot;&gt;simply the introduction of flash screens&lt;/a&gt;. (By the way, note the irony of a proud blog-post which deals with the performance optimizations an artifact whose sole purpose is to “entertain” the user while she’s waiting for the actual program to become available.)&lt;/p&gt;

&lt;p&gt;Finally, there is the emotional argument: bloated software simply makes me sad. As a user, at best, slow software takes a certain directness and feeling of control away from me. At worst, the experience is one of outright frustration and powerlessness. As professional creators of software, this poor user experience, multiplied by millions of users, is “on us”. Furthermore, the implication of bloated software is that we, as a field, have no idea what we’re doing. From such a position it is hard to feel professional pride.&lt;/p&gt;

&lt;p&gt;Making an emotional argument is always dangerous, even more so in such a cerebral field. However, I choose to &lt;em&gt;stay angry&lt;/em&gt; about the problem, until we can make it go away.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:knowledge-disclaimer&quot;&gt;
      &lt;p&gt;I should put up a big disclaimer here: perhaps such tools &lt;em&gt;do&lt;/em&gt; exist in particular specializations, such as real time software or games; In any case they did not receive major uptake in the general field of software development.&amp;nbsp;&lt;a href=&quot;#fnref:knowledge-disclaimer&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 03 Jul 2015 00:00:00 +0200</pubDate>
        <link>/articles/-software-bloat-makes-me-sad/</link>
        <guid isPermaLink="true">/articles/-software-bloat-makes-me-sad/</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Some thoughts on Software Development</title>
        <description>&lt;p&gt;In the past few months I’m having some recurring thoughts and questions&lt;sup id=&quot;fnref:alan-kay&quot;&gt;&lt;a href=&quot;#fn:alan-kay&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. What follows is mostly an attempt to force myself to structure these thougts and reach out to others that may share some insights on the subject. In other words: “warning: incoming rant.”&lt;/p&gt;

&lt;p&gt;The subject of these questions is the current state of our software (I hesitate to say: Software Engineering, but I suppose it is implied). The general theme is: “why is the quality of our software so low?”. Some of the questions are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Why is software generally so slow?&lt;/li&gt;
  &lt;li&gt;Why does software have so many bugs?&lt;/li&gt;
  &lt;li&gt;Why can my computer be hacked? Why do virusses exist?&lt;/li&gt;
  &lt;li&gt;Why do I need to restart my computer for this update? Why do updates exist at all?&lt;/li&gt;
  &lt;li&gt;Why is software so complex?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Assuming the premises are correct (software is generally slow, has many bugs etcetera), the consequences of not answering the questions are quite serious. A few examples:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unstable and buggy software makes its users feel powerless.&lt;/li&gt;
  &lt;li&gt;Bad performance means more computers running, which means a greater contribution to the greenhouse effect.&lt;/li&gt;
  &lt;li&gt;The lack of a workable security model has opened the way for mass surveillance.&lt;/li&gt;
  &lt;li&gt;Our lives are increasingly dependent on software. This means the above consequences are increasingly severe.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some observations and hints towards the answers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The answers to the questions may very well be related.&lt;/li&gt;
  &lt;li&gt;I have approximately 10 years of professional experience, yet I do not have the answers to the above questions ready.&lt;/li&gt;
  &lt;li&gt;I am not alone. The &lt;a href=&quot;/images/why-does-software-have-bugs-google.png&quot;&gt;top&lt;/a&gt; &lt;a href=&quot;/images/why-does-software-have-bugs-result-1.png&quot;&gt;Google&lt;/a&gt; &lt;a href=&quot;/images/why-does-software-have-bugs-result-2.png&quot;&gt;results&lt;/a&gt; &lt;a href=&quot;/images/why-does-software-have-bugs-result-3.png&quot;&gt;for&lt;/a&gt; “why does software have bugs” are spammy sites. Not serious people seriously answering a serious problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A few hints as to the answers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I do not have a full answer (yet?), but the title of this blog hints at some ideas.&lt;/li&gt;
  &lt;li&gt;Software Engineering as a field is very forgetful of its past.&lt;/li&gt;
  &lt;li&gt;We are a young field. There’s a lot of space for cowboys in the west, and in a gold rush it’s often more important who’s first than who’s right.&lt;/li&gt;
  &lt;li&gt;A lack of ambition keeps us from asking the important questions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope to expand on the above in more detail shortly.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:alan-kay&quot;&gt;
      &lt;p&gt;I’m not quite sure what exactly was at the root of these thoughts, but viewing Alan Kay’s talk at OOPSLA 1997, &lt;a href=&quot;https://www.youtube.com/watch?v=oKg1hTOQXoY&quot;&gt;The computer revolution hasn’t happened yet&lt;/a&gt;, has surely played a role&amp;nbsp;&lt;a href=&quot;#fnref:alan-kay&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 00:00:00 +0200</pubDate>
        <link>/articles/some-thougts/</link>
        <guid isPermaLink="true">/articles/some-thougts/</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Remarkably restrained</title>
        <description>&lt;p&gt;The more we allow our code to say the less we can be say about it.&lt;/p&gt;

&lt;p&gt;We must therefore measure the effectiveness of our tools not by how much we can do with them, but by how much we cannot do.&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 00:00:00 +0100</pubDate>
        <link>/articles/remarkably-restrained/</link>
        <guid isPermaLink="true">/articles/remarkably-restrained/</guid>
        
        
        <category>articles</category>
        
      </item>
    
  </channel>
</rss>
